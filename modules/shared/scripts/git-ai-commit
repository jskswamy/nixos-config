#!/usr/bin/env bash
set -e

# Color definitions for gum styling
RED=196
ORANGE=214

check_staged_changes() {
  if git diff --cached --quiet; then
    gum style --foreground $ORANGE "No staged changes to commit. Use 'git add' to stage changes first."
    exit 1
  fi
}

get_fabric_pattern() {
  if [ -n "$FABRIC_COMMIT_PATTERN" ]; then
    echo "$FABRIC_COMMIT_PATTERN"
    return
  fi

  # Separate arrays for descriptions and pattern names
  local descriptions=(
    "Standard Git commit"
    "Conventional commits"
    "Project update summary"
    "Technical diff summary"
  )

  local patterns=(
    "git_commit_message"
    "create_git_diff_commit"
    "summarize_git_changes"
    "summarize_git_diff"
  )

  # Let user select from descriptions
  local selected_description
  selected_description=$(printf "%s\n" "${descriptions[@]}" | gum choose --header "Select a fabric pattern for commit message generation:")

  # Find the index of selected description and return corresponding pattern
  for i in "${!descriptions[@]}"; do
    if [[ "${descriptions[$i]}" == "$selected_description" ]]; then
      echo "${patterns[$i]}"
      return
    fi
  done
}

generate_commit_message() {
  local pattern="$1"
  local git_root

  # Find git root directory
  git_root=$(git rev-parse --show-toplevel) || {
    gum style --foreground $RED "Error: Not in a git repository"
    exit 1
  }

  # Run fabric command and write directly to COMMIT_EDITMSG
  git dc | fabric -p "$pattern" >"$git_root/.git/COMMIT_EDITMSG" || exit 1
}

main() {
  check_staged_changes

  local pattern
  pattern=$(get_fabric_pattern)

  local git_root
  git_root=$(git rev-parse --show-toplevel)

  generate_commit_message "$pattern"

  # Use git commit with the generated message, allowing editing
  git commit --edit --file="$git_root/.git/COMMIT_EDITMSG"
}

main "$@"
